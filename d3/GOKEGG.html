<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>D3 Bar Chart – Import / URL then Run</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: sans-serif; }
    .controls { display:flex; gap:8px; justify-content:center; align-items:center; margin:16px auto; flex-wrap:wrap; }
    .controls input[type="text"] { width: 520px; padding:6px 8px; }
    .controls select {
      padding: 6px 8px;
      font-size: 14px;
      min-width: 160px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #fff;
      appearance: none;
    }
    .controls select,
    .controls input[type="text"],
    .controls button {
      height: 36px;
    }
    .hint { text-align:center; color:#666; font-size: 13px; margin-top:6px; }
    svg {
      border: 1px solid #ccc;
      background: #f9f9f9;
      display: block;
      margin: 12px auto;
      width: 50%;
      height: 800px;
    }

    .bar-label {
      font-size: 12px;
      pointer-events: none; /* 避免挡住鼠标事件 */
    }

  </style>
</head>
<body>

  <div class="controls">
    <button id="pick">选择 CSV/TSV 文件</button>
    <input type="file" id="file" accept=".csv,.tsv" hidden/>
    <input type="text" id="source" placeholder="在此显示文件名，或粘贴一个 http/https CSV/TSV 地址…" />
    <button id="run">Run</button>
  </div>

  <div class="controls">
    <select id="xField"></select>
    <select id="yField"></select>
    <select id="cField"></select>
    <select id="tField"></select>
    <select id="oField"></select>
  </div>

  <div class="hint">
    提示：本地文件不会暴露真实路径，只显示文件名；如需远程加载，可在输入框粘贴 CSV/TSV 的 URL（http/https）。
  </div>

  <svg id="mainsvg"></svg>

  <script>
    const svg = d3.select('#mainsvg');
    const margin = { top: 60, right: 30, bottom: 60, left: 120 };

    const pickBtn   = document.getElementById('pick');
    const fileInput = document.getElementById('file');
    const srcInput  = document.getElementById('source');
    const runBtn    = document.getElementById('run');

    const xSelect   = document.getElementById('xField'); // 分类（Y 轴，band）
    const ySelect   = document.getElementById('yField'); // 数值（X 轴，linear）
    const cSelect  = document.getElementById('cField'); // 颜色分组（可选）
    const tSelect  = document.getElementById('tField'); // 下方文字列（可选）
    const oSelect  = document.getElementById('oField'); // 圆圈列（可选，数值）

    let lastFile = null;   // 缓存最近一次用户选择的 File（本地文件）
    let lastData = null;   // 缓存最近一次渲染的数据（用于窗口 resize 重绘）

    // 初始把下拉禁用并放占位
    resetSelectors();

    pickBtn.addEventListener('click', () => fileInput.click());

    // 选择文件 → 只缓存，不立刻渲染；把文件名显示到文本框
    fileInput.addEventListener('change', async e  => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      lastFile = file;
      srcInput.value = file.name; // 仅文件名，非本地路径
      fileInput.value = ''; // 允许再次选择同名文件时依然触发 change
      // ↓↓↓ 新增：只读取表头并填充下拉（不渲染图）
      try {
        const columns = await getColumnsFromLocalFile(file);
        populateSelectors(columns);
      } catch (err) {
        console.error(err);
        alert('无法从本地 CSV/TSV 读取表头：' + (err && err.message ? err.message : err));
    }
    });


    // “扩展名判断 + 分隔符嗅探”工具
    function isTSVName(s) { return /\.tsv(\?.*)?$/i.test(s || ''); }
    function isCSVName(s) { return /\.csv(\?.*)?$/i.test(s || ''); }
    // 简单嗅探：看首个非空行里 \t 与 , 的数量
    function sniffDelimiter(text) {
      const firstLine = (text || '').split(/\r?\n/).find(l => l.trim().length > 0) || '';
      const tabs   = (firstLine.match(/\t/g) || []).length;
      const commas = (firstLine.match(/,/g)  || []).length;
      return tabs > commas ? '\t' : ','; // 默认回落 CSV
    }




    // 只读文件前 N 字节，避免整文件都读
    function readFileHeadAsText(file, encoding = 'utf-8', bytes = 65536) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error || new Error('File head read error'));
        reader.readAsText(file.slice(0, bytes), encoding);
      });
    }

    // 从本地文件提取 CSV 表头列名
    async function getColumnsFromLocalFile(file) {
      const head = await readFileHeadAsText(file);
      const delim = isTSVName(file.name) ? '\t' : isCSVName(file.name) ? ',' : sniffDelimiter(head); // 读取表头时支持 CSV/TSV
      const rows = d3.dsvFormat(delim).parseRows(head);
      const header = rows && rows[0] ? rows[0] : [];
      if (!header.length) throw new Error('未检测到 CSV 表头');
      return header;
    }


    srcInput.addEventListener('change', () => maybeLoadColumnsFromUrl());
    srcInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') maybeLoadColumnsFromUrl();
    });

    async function maybeLoadColumnsFromUrl() {
      const src = srcInput.value.trim();
      if (!isHttpUrl(src)) return; // 不是 http/https 就不处理
      try {
        // 这里只拿文本，解析首行当表头，避免全量解析
        const text = await d3.text(src);
        // const rows = d3.csvParseRows(text);
        const delim = isTSVName(src) ? '\t' : isCSVName(src) ? ',' : sniffDelimiter(text); // maybeLoadColumnsFromUrl() 中按扩展名或嗅探：
        const rows  = d3.dsvFormat(delim).parseRows(text);
        const header = rows && rows[0] ? rows[0] : [];
        if (!header.length) throw new Error('未在该 URL 中检测到 CSV/TSV 表头');
        populateSelectors(header);
      } catch (err) {
        console.error(err);
        alert('无法从该 URL 读取表头（可能是 CORS 或格式问题）：' + (err && err.message ? err.message : err));
      }
    }





    // Run 按钮：根据输入框内容决定是读取本地 File 还是拉取 URL
  runBtn.addEventListener('click', async () => {
    const src = srcInput.value.trim();
    try {
      let data;
      if (isHttpUrl(src)) {
        // 真正加载数据并渲染时支持 CSV/TSV // data = await d3.csv(src, d3.autoType);
        if (isTSVName(src)) {
          data = await d3.tsv(src, d3.autoType);
        } else if (isCSVName(src)) {
          data = await d3.csv(src, d3.autoType);
        } else {
          const text = await d3.text(src);
          const delim = sniffDelimiter(text);
          data = d3.dsvFormat(delim).parse(text, d3.autoType);
        }
      } else if (lastFile) {
        const text = await readFileAsText(lastFile, 'utf-8');
        // data = d3.csvParse(text, d3.autoType);
        const delim = isTSVName(lastFile.name) ? '\t' : isCSVName(lastFile.name) ? ',' : sniffDelimiter(text); 
        data = d3.dsvFormat(delim).parse(text, d3.autoType);
      } else {
        alert('请先选择本地 CSV/TSV http/https 的 CSV/TSV 地址。');
        return;
      }

      // // 这里再次填充一次下拉也没问题（保证同步）
      // const columns = data.columns || Object.keys(data[0] || {});
      // if (Array.isArray(columns) && columns.length) {
      //   populateSelectors(columns);
      // }

      lastData = data;
      render(lastData); // 真正画图
    } catch (err) {
      console.error(err);
      alert('读取或解析失败：' + (err && err.message ? err.message : err));
    }
  });






    // 下拉改变 → 即时重绘
    xSelect.addEventListener('change', () => { if (lastData) render(lastData); });
    ySelect.addEventListener('change', () => { if (lastData) render(lastData); });
    cSelect.addEventListener('change', () => { if (lastData) render(lastData); });
    tSelect.addEventListener('change', () => { if (lastData) render(lastData); });


    // 工具：判断是否 http/https URL
    function isHttpUrl(s) {
      try {
        const u = new URL(s);
        return u.protocol === 'http:' || u.protocol === 'https:';
      } catch { return false; }
    }

    // 工具：FileReader → Promise
    function readFileAsText(file, encoding = 'utf-8') {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error || new Error('File read error'));
        reader.readAsText(file, encoding);
      });
    }

    // 下拉：重置为禁用占位
    function resetSelectors() {
      xSelect.innerHTML = '<option disabled selected>先加载 CSV/TSV… （分类列）</option>';
      ySelect.innerHTML = '<option disabled selected>先加载 CSV/TSV… （数值列）</option>';
      cSelect.innerHTML = '<option disabled selected>先加载 CSV/TSV… （颜色分组 列，可选）</option>';
      tSelect.innerHTML = '<option disabled selected>先加载 CSV/TSV… （下方文字 列，可选）</option>';
      oSelect.innerHTML = '<option disabled selected>先加载 CSV/TSV… （圆圈列，可选，数值）</option>';
      xSelect.disabled = true;
      ySelect.disabled = true;
      cSelect.disabled = true;
      tSelect.disabled = true;
      oSelect.disabled = true;
    }
      
    // 1) 加载数据后提取字段并填充下拉
    function populateSelectors(columns) {
      xSelect.disabled = false;
      ySelect.disabled = false;
      cSelect.disabled = false;
      tSelect.disabled = false;
      oSelect.disabled = false;

      xSelect.innerHTML = '';
      ySelect.innerHTML = '';
      cSelect.innerHTML = '';
      tSelect.innerHTML = '';
      oSelect.innerHTML = '';

      // x / y：全部列
      for (const col of columns) {
        xSelect.add(new Option(col, col));
        ySelect.add(new Option(col, col));
      }

      // c 下拉：第一项是“无分组”，其后是所有列
      cSelect.add(new Option('（不按颜色分组）', ''));
      for (const col of columns) {
        cSelect.add(new Option(col, col));
      }

      // t 下拉：第一项“不显示下方文字”
      tSelect.add(new Option('（不显示下方文字）', ''));
      for (const col of columns) {
        tSelect.add(new Option(col, col));
      }


      // o：圆圈列（数值），第一项“不绘制圆圈”
      oSelect.add(new Option('（不绘制圆圈）', ''));
      for (const col of columns) oSelect.add(new Option(col, col));

      // 智能默认：分类列常见命名；数值列常见命名
      const guessCat = columns.find(c => /(platform|name|category|type|label|city|country)/i.test(c)) ?? columns[0];
      const guessVal = columns.find(c => /(global|sale|value|amount|total|score|count|num|quantity|qty|price)/i.test(c)) 
                    ?? columns.find(c => c !== guessCat) 
                    ?? columns[0];
      const guessCol = columns.find(c => /^ontology$/i.test(c)) ?? ''; // 有 ONTOLOGY 就默认选它，否则不分组
      const guessTxt = columns.find(c => /(desc|label2|subtitle|note|info|text)/i.test(c)) ?? '';


      xSelect.value = guessCat;
      ySelect.value = guessVal;
      cSelect.value = guessCol;
      tSelect.value = guessTxt;       // 下方文字默认不显示；若存在常见命名可自动猜测
      oSelect.value = '';       // 默认不画圆圈


    }


    // 计算画布尺寸（width="100%" 时不能用 attr('width')）
    function getSize() {
      const width  = svg.node().getBoundingClientRect().width;
      const height = svg.node().getBoundingClientRect().height;
      return { width, height };
    }

    // // 渲染函数（与你原来的逻辑一致，略有健壮性增强）
    // function render(data) {

    //   // 清洗 & 类型转换（d3.autoType 已做基础推断，这里再保险一次）
    //   const xField = document.getElementById('xField').value;
    //   const yField = document.getElementById('yField').value;
    //   const cField = cSelect.value || null; // 颜色分组（可为空）
    //   const tField = tSelect.value || null;    // 下方文字列（可为空）

    //   data = data.map(d => ({
    //     x: d[xField],
    //     y: +d[yField],
    //     g: cField ? d[cField] : null,
    //     t: tField ? d[tField] : null
    //   })).filter(d => d.x != null && !Number.isNaN(d.y));

    //   // data = data.map(d => ({
    //   //   platform: d.platform,
    //   //   globalsale: +d.globalsale
    //   // })).filter(d => d.platform != null && !Number.isNaN(d.globalsale));


    //   svg.selectAll('*').remove();

    //   const { width, height } = getSize();
    //   const innerWidth  = width  - margin.left - margin.right;
    //   const innerHeight = height - margin.top  - margin.bottom;

    //   const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    //   // const x = d3.scaleLinear()
    //   //   // .domain([0, d3.max(data, d => d.globalsale) || 0])
    //   //   .domain([0, d3.max(data, d => d.x) || 0])
    //   //   .nice()
    //   //   .range([0, innerWidth]);

    //   // const y = d3.scaleBand()
    //   //   // .domain(data.map(d => d.platform))
    //   //   .domain(data.map(d => d.y))
    //   //   .range([0, innerHeight])
    //   //   .padding(0.1);

    //   const x = d3.scaleLinear()
    //     .domain([0, d3.max(data, d => d.y) || 0]) // ✅ X 轴用数值 y
    //     .nice()
    //     .range([0, innerWidth]);

    //   const y = d3.scaleBand()
    //     .domain(data.map(d => String(d.x))) // ✅ Y 轴用分类 x
    //     .range([0, innerHeight])
    //     .padding(0.1);


    //   // 颜色比例尺：当选择了分组列时启用
    //   const groups = cField ? Array.from(new Set(data.map(d => d.g))) : [];
    //   const colorRange = groups.length <= 10
    //     ? d3.schemeTableau10
    //     : d3.quantize(d3.interpolateRainbow, groups.length);
    //   const color = groups.length ? d3.scaleOrdinal().domain(groups).range(colorRange) : null;


    //   // 条形
    //   g.selectAll('rect')
    //     .data(data)
    //     .join('rect')
    //     .attr('x', 0)
    //     // .attr('y', d => y(d.platform))
    //     // .attr('width', d => x(d.globalsale))
    //     // .attr('y', d => y(d.y))
    //     // .attr('width', d => x(d.x))
    //     .attr('y', d => y(String(d.x)))
    //     .attr('width', d => x(d.y))
    //     .attr('height', y.bandwidth())
    //     // .attr('fill', 'steelblue')
    //     .attr('fill', d => color ? color(d.g) : 'steelblue')
    //     .attr('rx', d => Math.min(3, y.bandwidth()/2, x(d.y)/2)) // 倒角
    //     .attr('ry', d => Math.min(3, y.bandwidth()/2, x(d.y)/2)) // 倒角


    //   // === 在横条里放“Y 轴刻度文字”（分类名）===
    //   const PADDING = 6;       // 文字与条左边的内边距
    //   const INSIDE_MIN_W = 40; // 条太短时把文字放到条外侧，避免看不清
    //   const textColorFor = (bg) => {   // 根据背景自动选黑/白
    //     const c = d3.color(bg || '#000');
    //     const L = 0.299 * c.r + 0.587 * c.g + 0.114 * c.b;
    //     return L < 140 ? 'white' : '#111';
    //   };



    //   g.selectAll('text.bar-label')
    //     .data(data)
    //     .join('text')
    //     .attr('class', 'bar-label')
    //     .attr('x', d => {
    //       const w = x(d.y);
    //       return w > INSIDE_MIN_W ? PADDING : w + PADDING; // 条短→放条外
    //     })
    //     .attr('y', d => y(String(d.x)) + y.bandwidth()/2)
    //     .attr('dy', '0.35em') // 垂直居中微调
    //     .attr('text-anchor', 'start')
    //     // .attr('fill', d => x(d.y) > INSIDE_MIN_W ? 'white' : '#333')
    //     .attr('fill', d => {
    //       const w = x(d.y);
    //       const bg = color ? color(d.g) : 'steelblue';
    //       return w > INSIDE_MIN_W ? textColorFor(bg) : '#333';
    //     })
    //     .text(d => String(d.x)); // 用分类名作为“Y轴刻度文字”


    //   // 轴
    //   g.append('g')
    //     .attr('transform', `translate(0,${innerHeight})`)
    //     .call(d3.axisBottom(x))
    //     .call(g => g.selectAll('.tick text').attr('font-size', '12px'));

    //   // g.append('g')
    //   //   .call(d3.axisLeft(y))
    //   //   .call(g => g.selectAll('.tick text').attr('font-size', '12px'));

    //   // 标题 & 轴标题（根据字段名更新）
    //   svg.append('text')
    //     .attr('x', width / 2)
    //     .attr('y', 28)
    //     .attr('text-anchor', 'middle')
    //     .attr('font-size', '20px')
    //     .text(`${xField} vs ${yField}`);

    //   g.append('text')
    //     .attr('x', innerWidth / 2)
    //     .attr('y', innerHeight + 40)
    //     .attr('text-anchor', 'middle')
    //     .attr('fill', 'black')
    //     .text(yField);

    //   g.append('text')
    //     .attr('transform', 'rotate(-90)')
    //     .attr('x', -innerHeight / 2)
    //     .attr('y', -80)
    //     .attr('text-anchor', 'middle')
    //     .attr('fill', 'black')
    //     .text(xField);
      
    //   // // 缩放：保持边距不丢失
    //   // const zoom = d3.zoom()
    //   // //   .scaleExtent([0.5, 10])
    //   // .on("zoom", (event) => {
    //   //     g.attr("transform", event.transform);
    //   // });




    //   // 图例（当有分组时）
    //   g.selectAll('.legend').remove();
    //   if (groups.length) {
    //     const legend = g.append('g').attr('class', 'legend')
    //       .attr('transform', `translate(${Math.max(0, innerWidth - 160)}, 0)`);

    //     const li = legend.selectAll('g.item')
    //       .data(groups)
    //       .join('g')
    //       .attr('class', 'item')
    //       .attr('transform', (d, i) => `translate(0, ${i * 18})`);

    //     li.append('rect')
    //       .attr('width', 12).attr('height', 12).attr('rx', 2).attr('ry', 2)
    //       .attr('fill', d => color(d));

    //     li.append('text')
    //       .attr('x', 16).attr('y', 6).attr('dy', '0.35em')
    //       .attr('font-size', 12)
    //       .text(d => d);
    //   }


    //   const zoom = d3.zoom()
    //   // .scaleExtent([0.5, 10])
    //   .on('zoom', (event) => {
    //     // ✅ 把边距再加回去，缩放时不丢失 margin
    //     g.attr('transform', event.transform.translate(margin.left, margin.top));
    //   });
    //   svg.on('.zoom', null); // 清理旧的 listener，避免叠加
    //   svg.call(zoom);

    // }

    // function render(raw) {
    //   const xField = xSelect.value;          // 分类（Y）
    //   const yField = ySelect.value;          // 数值（第2个下拉）
    //   const cField = cSelect.value || null;  // 分组（着色）
    //   const tField = tSelect.value || '';    // 文本列（可选；若为空就用 xField）

    //   // 先别强转 t；保留原始文本
    //   let rows = raw.map(d => ({
    //     x: d[xField],
    //     y: +d[yField],
    //     g: cField ? d[cField] : null,
    //     t: tField ? d[tField] : null
    //   })).filter(d => d.x != null && !Number.isNaN(d.y));

    //   // tField 是否是“数值列”（如果是，则会出现两根并排）
    //   const tIsNumeric = !!tField && rows.some(d => d.t != null && d.t !== '' && !Number.isNaN(+d.t));

    //   // 长表：{x, s(系列名), v(值), g(分组), label(用于条内文字的原文)}
    //   const seriesNames = tIsNumeric ? [yField, tField] : [yField];
    //   const data = tIsNumeric
    //     ? rows.flatMap(d => [
    //         { x: String(d.x), s: yField, v: d.y,   g: d.g, label: d.t },
    //         { x: String(d.x), s: tField, v: +d.t,  g: d.g, label: d.t }
    //       ]).filter(d => !Number.isNaN(d.v))
    //     : rows.map(d => ({ x: String(d.x), s: yField, v: d.y, g: d.g, label: d.t }));

    //   svg.selectAll('*').remove();

    //   const { width, height } = getSize();
    //   const innerWidth  = width  - margin.left - margin.right;
    //   const innerHeight = height - margin.top  - margin.bottom;
    //   const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    //   // 比例尺
    //   const cats = Array.from(new Set(data.map(d => d.x)));
    //   const x = d3.scaleLinear()
    //     .domain([0, d3.max(data, d => d.v) || 0]).nice()
    //     .range([0, innerWidth]);

    //   const y0 = d3.scaleBand()
    //     .domain(cats)
    //     .range([0, 3.3 * innerHeight])
    //     .paddingInner(0.12);

    //   const y1 = d3.scaleBand()
    //     .domain(seriesNames)
    //     .range([0, y0.bandwidth()])
    //     .padding(seriesNames.length > 1 ? 0.12 : 0.0);

    //   // 颜色：按 cField 分组；没选 cField 时按系列
    //   const groups = cField ? Array.from(new Set(data.map(d => d.g))) : [];
    //   const color = groups.length
    //     ? d3.scaleOrdinal().domain(groups)
    //         .range(groups.length <= 10 ? d3.schemeTableau10 : d3.quantize(d3.interpolateRainbow, groups.length))
    //     : d3.scaleOrdinal().domain(seriesNames).range(d3.schemeTableau10.slice(0, seriesNames.length));
    //   const fillOf = d => groups.length ? color(d.g) : color(d.s);

    //   // 画条
    //   const catG = g.selectAll('.cat')
    //     .data(cats)
    //     .join('g')
    //       .attr('class', 'cat')
    //       .attr('transform', d => `translate(0,${y0(d)})`);

    //   catG.selectAll('rect')
    //     .data(cat => data.filter(e => e.x === cat))
    //     .join('rect')
    //       .attr('x', 0)
    //       .attr('y', d => y1(d.s))
    //       .attr('width', d => x(d.v))
    //       .attr('height', y1.bandwidth())
    //       .attr('fill', d => fillOf(d))
    //       .attr('fill-opacity', d => tIsNumeric ? (d.s === yField ? 0.95 : 0.55) : 0.95)
    //       .attr('rx', d => Math.min(3, y1.bandwidth()/2, x(d.v)/2))
    //       .attr('ry', d => Math.min(3, y1.bandwidth()/2, x(d.v)/2));

    //   // === 条内文字（关键改动）===
    //   // 文本优先级：若 tField 是“文本列” -> 用 tField；否则回退到 xField
    //   const PADDING = 6, INSIDE_MIN_W = 40;
    //   const labelText = d => {
    //     const txt = (!tIsNumeric && tField && d.label != null && d.label !== '') ? String(d.label) : d.x;
    //     return txt;
    //   };
    //   const textColorFor = (bg) => {
    //     const c = d3.color(bg || '#000'); const L = 0.299*c.r + 0.587*c.g + 0.114*c.b;
    //     return L < 140 ? 'white' : '#111';
    //   };

    //   // 只给“第2个下拉（yField）”对应的那根条加文字
    //   catG.selectAll('text.bar-label')
    //     .data(cat => data.filter(e => e.x === cat && e.s === yField))
    //     .join('text')
    //       .attr('class', 'bar-label')
    //       .attr('x', d => {
    //         const w = x(d.v);
    //         return w > INSIDE_MIN_W ? PADDING : w + PADDING;
    //       })
    //       .attr('y', d => y1(d.s) + y1.bandwidth()/2)
    //       .attr('dy', '0.35em')
    //       .attr('text-anchor', 'start')
    //       .attr('fill', d => {
    //         const w = x(d.v);
    //         const bg = fillOf(d);
    //         return w > INSIDE_MIN_W ? textColorFor(bg) : '#333';
    //       })
    //       .text(d => labelText(d));

    //   // 轴：X 正常；Y 轴只保留位置，去掉刻度文字（不再把 xField 文本显示在轴上）
    //   g.append('g')
    //     .attr('transform', `translate(0,${3.3 * innerHeight})`)
    //     .call(d3.axisBottom(x))
    //     .call(g => g.selectAll('.tick text').attr('font-size', '12px'));

    //   g.append('g')
    //     .call(d3.axisLeft(y0).tickSize(0).tickFormat(() => '')); // ← 隐藏 Y 轴刻度文字

    //   // 标题
    //   svg.append('text')
    //     .attr('x', width / 2)
    //     .attr('y', 28)
    //     .attr('text-anchor', 'middle')
    //     .attr('font-size', '20px')
    //     .text(() => {
    //       if (tIsNumeric) return `${xField}：${yField} vs ${tField}（按 ${cField || '无分组'} 着色）`;
    //       if (tField)     return `${xField}（条内显示：${tField}，着色：${cField || '无分组'}）`;
    //       return `${xField}（条内显示：${xField}，着色：${cField || '无分组'}）`;
    //     });

    //   // 分组图例
    //   g.selectAll('.legend').remove();
    //   if (groups.length) {
    //     const legend = g.append('g').attr('class', 'legend')
    //       .attr('transform', `translate(${Math.max(0, innerWidth - 160)}, 0)`);
    //     const li = legend.selectAll('g.item')
    //       .data(groups)
    //       .join('g')
    //         .attr('class', 'item')
    //         .attr('transform', (d, i) => `translate(0, ${i * 18})`);
    //     li.append('rect')
    //       .attr('width', 12).attr('height', 12).attr('rx', 2).attr('ry', 2)
    //       .attr('fill', d => color(d));
    //     li.append('text')
    //       .attr('x', 16).attr('y', 6).attr('dy', '0.35em')
    //       .attr('font-size', 12)
    //       .text(d => d);
    //   }

    //   // 二系列时的“小系列说明”（透明度区分），可留可删
    //   if (tIsNumeric) {
    //     const seriesLegend = g.append('g').attr('class', 'legend series-legend')
    //       .attr('transform', `translate(${Math.max(0, innerWidth - 160)}, ${groups.length ? (groups.length*18 + 10) : 0})`);
    //     const sl = seriesLegend.selectAll('g.item')
    //       .data(seriesNames)
    //       .join('g')
    //         .attr('class', 'item')
    //         .attr('transform', (d, i) => `translate(0, ${i * 18})`);
    //     sl.append('rect')
    //       .attr('width', 12).attr('height', 12).attr('rx', 2).attr('ry', 2)
    //       .attr('fill', '#777')
    //       .attr('fill-opacity', d => d === yField ? 0.95 : 0.55);
    //     sl.append('text')
    //       .attr('x', 16).attr('y', 6).attr('dy', '0.35em')
    //       .attr('font-size', 12)
    //       .text(d => d);
    //   }

    //   // 缩放
    //   const zoom = d3.zoom().on('zoom', (event) => {
    //     g.attr('transform', event.transform.translate(margin.left, margin.top));
    //   });
    //   svg.on('.zoom', null);
    //   svg.call(zoom);
    // }


    // // 完成second bar and text
    // function render(raw) {
    //   const xField = xSelect.value;          // 分类（Y 轴）
    //   const yField = ySelect.value;          // 数值1（第一根条）
    //   const cField = cSelect.value || null;  // 分组（着色）
    //   const tField = tSelect.value || '';    // 第二槽位：文字或第二数值

    //   // 读取行（保留 t 原值用于判断是否数字）
    //   const rows = raw.map(d => ({
    //     x: d[xField],
    //     y: +d[yField],
    //     g: cField ? d[cField] : null,
    //     t: tField ? d[tField] : null
    //   })).filter(d => d.x != null && !Number.isNaN(d.y));

    //   const tChosen    = !!tField;
    //   const tIsNumeric = tChosen && rows.some(d => d.t != null && d.t !== '' && !Number.isNaN(+d.t));

    //   // 画布
    //   svg.selectAll('*').remove();
    //   const { width, height } = getSize();
    //   const innerWidth  = width  - margin.left - margin.right;
    //   const innerHeight = height - margin.top  - margin.bottom;
    //   const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    //   // 维度域 & 比例尺
    //   const cats = Array.from(new Set(rows.map(d => String(d.x))));
    //   // 两个槽位都保留（t 为文本时也要给它一个“槽位”放文字）
    //   const seriesNames = tChosen ? [yField, tField] : [yField];

    //   // 实际会绘制的条：第一条必有；第二条仅在 t 为数字时绘制
    //   const bars = [];
    //   for (const d of rows) {
    //     bars.push({ x: String(d.x), s: yField, v: d.y,  g: d.g });
    //     if (tIsNumeric) {
    //       const v2 = +d.t;
    //       if (!Number.isNaN(v2)) bars.push({ x: String(d.x), s: tField, v: v2, g: d.g });
    //     }
    //   }

    //   const x = d3.scaleLinear()
    //     .domain([0, d3.max(bars, d => d.v) || 0]).nice()
    //     .range([0, innerWidth]);

    //   const y0 = d3.scaleBand()
    //     .domain(cats)
    //     .range([0, 3.3 * innerHeight])
    //     .paddingInner(0.12);

    //   const y1 = d3.scaleBand()
    //     .domain(seriesNames)
    //     .range([0, y0.bandwidth()])
    //     .padding(seriesNames.length > 1 ? 0.12 : 0.0);

    //   // 颜色（按 cField 分组；若未选 cField，退化为按槽位上色）
    //   const groups = cField ? Array.from(new Set(rows.map(d => d.g))) : [];
    //   const color = groups.length
    //     ? d3.scaleOrdinal().domain(groups)
    //         .range(groups.length <= 10 ? d3.schemeTableau10
    //                                   : d3.quantize(d3.interpolateRainbow, groups.length))
    //     : d3.scaleOrdinal().domain(seriesNames).range(d3.schemeTableau10.slice(0, seriesNames.length));
    //   const fillOf = d => groups.length ? color(d.g) : color(d.s);

    //   // 条形（第一条必画，第二条仅数字时画）
    //   const catG = g.selectAll('.cat')
    //     .data(cats)
    //     .join('g')
    //       .attr('class', 'cat')
    //       .attr('transform', d => `translate(0,${y0(d)})`);

    //   catG.selectAll('rect')
    //     .data(cat => bars.filter(e => e.x === cat))
    //     .join('rect')
    //       .attr('x', 0)
    //       .attr('y', d => y1(d.s))
    //       .attr('width', d => x(d.v))
    //       .attr('height', y1.bandwidth())
    //       .attr('fill', d => fillOf(d))
    //       .attr('rx', d => Math.min(3, y1.bandwidth()/2, x(d.v)/2))
    //       .attr('ry', d => Math.min(3, y1.bandwidth()/2, x(d.v)/2));

    //   // === 条内文字（第一个 option：xField）——显示在第一根条里 ===
    //   const PADDING = 6, INSIDE_MIN_W = 40;
    //   const textColorFor = (bg) => {
    //     const c = d3.color(bg || '#000'); const L = 0.299*c.r + 0.587*c.g + 0.114*c.b;
    //     return L < 140 ? 'white' : '#111';
    //   };

    //   // 只给第一槽位（yField）的条加 xField 文本
    //   catG.selectAll('text.x-in-bar')
    //     .data(cat => bars.filter(e => e.x === cat && e.s === yField))
    //     .join('text')
    //       .attr('class', 'x-in-bar')
    //       .attr('x', d => {
    //         const w = x(d.v);
    //         return w > INSIDE_MIN_W ? PADDING : w + PADDING;
    //       })
    //       .attr('y', d => y1(d.s) + y1.bandwidth()/2)
    //       .attr('dy', '0.35em')
    //       .attr('text-anchor', 'start')
    //       .attr('fill', d => {
    //         const w = x(d.v);
    //         const bg = fillOf(d);
    //         return w > INSIDE_MIN_W ? textColorFor(bg) : '#333';
    //       })
    //       .text(d => d.x); // ← 第一个 option 的文字（分类名）

    //   // === 第二槽位（tField）：文字或条 ===
    //   // t 为文本：不画条，只在它应在的位置显示文字，颜色由 cField 控制
    //   if (tChosen && !tIsNumeric) {
    //     catG.selectAll('text.t-slot')
    //       .data(cat => rows.filter(e => String(e.x) === cat))
    //       .join('text')
    //         .attr('class', 't-slot')
    //         .attr('x', PADDING)
    //         .attr('y', y1(tField) + y1.bandwidth()/2)
    //         .attr('dy', '0.35em')
    //         .attr('text-anchor', 'start')
    //         .attr('font-size', 12)
    //         .attr('fill', d => groups.length ? color(d.g) : '#333') // ← 受第三个 option（cField）控制
    //         .text(d => (d.t != null && d.t !== '') ? String(d.t) : '');
    //   }

    //   // 轴：X 正常；Y 轴隐藏文字（避免与条内文字重复）
    //   g.append('g')
    //     .attr('transform', `translate(0,${3.3 * innerHeight})`)
    //     .call(d3.axisBottom(x))
    //     .call(g => g.selectAll('.tick text').attr('font-size', '12px'));

    //   g.append('g')
    //     .call(d3.axisLeft(y0).tickSize(0).tickFormat(() => ''));

    //   // 分组图例（按 cField）
    //   g.selectAll('.legend').remove();
    //   if (groups.length) {
    //     const legend = g.append('g').attr('class', 'legend')
    //       .attr('transform', `translate(${Math.max(0, innerWidth - 160)}, 0)`);
    //     const li = legend.selectAll('g.item')
    //       .data(groups)
    //       .join('g')
    //         .attr('class', 'item')
    //         .attr('transform', (d, i) => `translate(0, ${i * 18})`);
    //     li.append('rect')
    //       .attr('width', 12).attr('height', 12).attr('rx', 2).attr('ry', 2)
    //       .attr('fill', d => color(d));
    //     li.append('text')
    //       .attr('x', 16).attr('y', 6).attr('dy', '0.35em')
    //       .attr('font-size', 12)
    //       .text(d => d);
    //   }

    //   // 标题（可选）
    //   svg.append('text')
    //     .attr('x', width / 2)
    //     .attr('y', 28)
    //     .attr('text-anchor', 'middle')
    //     .attr('font-size', '20px')
    //     .text(() => {
    //       if (!tChosen) return `${xField} vs ${yField}（着色：${cField || '无分组'}）`;
    //       return tIsNumeric
    //         ? `${xField}：${yField}（条） vs ${tField}（条）｜着色：${cField || '无分组'}`
    //         : `${xField}：${yField}（条内显 ${xField}），${tField}（第二槽位文本，按 ${cField || '无分组'} 着色）`;
    //     });

    //   // 缩放
    //   const zoom = d3.zoom().on('zoom', (event) => {
    //     g.attr('transform', event.transform.translate(margin.left, margin.top));
    //   });
    //   svg.on('.zoom', null);
    //   svg.call(zoom);
    // }

    function render(raw) {
      const xField = xSelect.value;          // 分类（Y 轴）
      const yField = ySelect.value;          // 数值1（第一根条）
      const cField = cSelect.value || null;  // 分组（着色）
      const tField = tSelect.value || '';    // 第二槽位：文字或第二数值（可选）
      const oField = oSelect.value || '';    // 圆圈列（可选，数值）

      // 读取行（保留 t 原值；o 尝试转数值）
      const rows = raw.map(d => ({
        x: d[xField],
        y: +d[yField],
        g: cField ? d[cField] : null,
        t: tField ? d[tField] : null,
        o: oField ? +d[oField] : NaN
      })).filter(d => d.x != null && !Number.isNaN(d.y));

      const tChosen    = !!tField;
      const tIsNumeric = tChosen && rows.some(d => d.t != null && d.t !== '' && !Number.isNaN(+d.t));
      const oChosen    = !!oField;
      const oMax       = oChosen ? d3.max(rows, d => Number.isFinite(d.o) ? d.o : NaN) : 0;

      // 清空 & 画布
      svg.selectAll('*').remove();
      const { width, height } = getSize();
      const innerWidth  = width  - margin.left - margin.right;
      const innerHeight = height - margin.top  - margin.bottom;

      // 先创建 g，稍后根据圆圈需要的额外左边距再更新 transform
      const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

      // 维度域 & 比例尺
      const cats = Array.from(new Set(rows.map(d => String(d.x))));
      const seriesNames = tChosen ? [yField, tField] : [yField];

      // bars（真正绘制的矩形）：第一条必有；第二条仅 t 为数字时绘制
      const bars = [];
      for (const d of rows) {
        bars.push({ x: String(d.x), s: yField, v: d.y,  g: d.g });
        if (tIsNumeric) {
          const v2 = +d.t;
          if (!Number.isNaN(v2)) bars.push({ x: String(d.x), s: tField, v: v2, g: d.g });
        }
      }

      const x = d3.scaleLinear()
        .domain([0, d3.max(bars, d => d.v) || 0]).nice()
        .range([0, innerWidth]);

      // 你当前用的是“加长高度”的方式，这里保持一致（3.3 倍）
      const y0 = d3.scaleBand()
        .domain(cats)
        .range([0, 3.3 * innerHeight])
        .paddingInner(0.12);

      const y1 = d3.scaleBand()
        .domain(seriesNames)
        .range([0, y0.bandwidth()])
        .padding(seriesNames.length > 1 ? 0.12 : 0.0);

      // 分组着色（优先按 cField；没有分组时按槽位上色）
      const groups = cField ? Array.from(new Set(rows.map(d => d.g))) : [];
      const color = groups.length
        ? d3.scaleOrdinal().domain(groups)
            .range(groups.length <= 10 ? d3.schemeTableau10
                                      : d3.quantize(d3.interpolateRainbow, groups.length))
        : d3.scaleOrdinal().domain(seriesNames).range(d3.schemeTableau10.slice(0, seriesNames.length));
      const fillOf = d => groups.length ? color(d.g) : color(d.s);

      // ==== 圆圈列：半径比例尺（直径与该分类“两个 bar 的总体高度”对应）====
      // 最大直径 = y0.bandwidth()；按数值线性映射到直径 → 半径
      const rScale = (oChosen && oMax > 0)
        ? d3.scaleLinear().domain([0, oMax]).range([0, y0.bandwidth() / 2])
        : null;

      // 根据最大半径，为左侧自动留白，避免圆圈被裁剪
      const maxR     = rScale ? rScale(oMax) : 0;
      const extraLeft = rScale ? (maxR * 2 + 12) : 0; // 左侧再留 12px 的间距
      g.attr('transform', `translate(${margin.left + extraLeft},${margin.top})`);

      // ====== 矩形条形（第一条必画，第二条仅数字时画）======
      const catG = g.selectAll('.cat')
        .data(cats)
        .join('g')
          .attr('class', 'cat')
          .attr('transform', d => `translate(0,${y0(d)})`);

      catG.selectAll('rect')
        .data(cat => bars.filter(e => e.x === cat))
        .join('rect')
          .attr('x', 0)
          .attr('y', d => y1(d.s))
          .attr('width', d => x(d.v))
          .attr('height', y1.bandwidth())
          .attr('fill', d => fillOf(d))
          .attr('rx', d => Math.min(3, y1.bandwidth()/2, x(d.v)/2))
          .attr('ry', d => Math.min(3, y1.bandwidth()/2, x(d.v)/2));

      // ====== 条内文字：在“第一槽位（yField）”里显示 xField 文本 ======
      const PADDING = 6, INSIDE_MIN_W = 40;
      const textColorFor = (bg) => {
        const c = d3.color(bg || '#000'); const L = 0.299*c.r + 0.587*c.g + 0.114*c.b;
        return L < 140 ? 'white' : '#111';
      };

      catG.selectAll('text.x-in-bar')
        .data(cat => bars.filter(e => e.x === cat && e.s === yField))
        .join('text')
          .attr('class', 'x-in-bar')
          .attr('x', d => {
            const w = x(d.v);
            return w > INSIDE_MIN_W ? PADDING : w + PADDING;
          })
          .attr('y', d => y1(d.s) + y1.bandwidth()/2)
          .attr('dy', '0.35em')
          .attr('text-anchor', 'start')
          .attr('fill', d => {
            const w = x(d.v);
            const bg = fillOf(d);
            return w > INSIDE_MIN_W ? textColorFor(bg) : '#333';
          })
          .text(d => d.x);

      // ====== 第二槽位（tField）：文字或条 ======
      if (tChosen && !tIsNumeric) {
        // 文本：不画条，只在第二槽位位置显示，颜色由 cField 控制
        catG.selectAll('text.t-slot')
          .data(cat => rows.filter(e => String(e.x) === cat))
          .join('text')
            .attr('class', 't-slot')
            .attr('x', PADDING)
            .attr('y', y1(tField) + y1.bandwidth()/2)
            .attr('dy', '0.35em')
            .attr('text-anchor', 'start')
            .attr('font-size', 12)
            .attr('fill', d => groups.length ? color(d.g) : '#333')
            .text(d => (d.t != null && d.t !== '') ? String(d.t) : '');
      }

      // ====== 圆圈：在刻度左侧，圆心对齐分类中心，直径按 oField 映射 ======
      if (rScale) {
        const circles = g.append('g').attr('class', 'o-circles');
        circles.selectAll('circle')
          .data(rows)
          .join('circle')
            .attr('cx', d => {
              const r = rScale(Math.max(0, Number.isFinite(d.o) ? d.o : 0));
              // return -r - 8; // 在 y 轴左侧一点点（8px）间距
              return -20; // 在 y 轴左侧一点点（8px）间距
            })
            .attr('cy', d => y0(String(d.x)) + y0.bandwidth()/2)
            .attr('r',  d => rScale(Math.max(0, Number.isFinite(d.o) ? d.o : 0)))
            .attr('fill', 'none')
            .attr('stroke', d => groups.length ? color(d.g) : '#666')
            .attr('stroke-width', 1.5);
      }

      // ====== 坐标轴 ======
      g.append('g')
        .attr('transform', `translate(0,${3.3 * innerHeight})`)
        .call(d3.axisBottom(x))
        .call(g => g.selectAll('.tick text').attr('font-size', '12px'));

      // 隐藏 Y 轴文字（避免与条内文字重复），保留刻度线需要的话可改 tickSize
      g.append('g')
        .call(d3.axisLeft(y0).tickSize(0).tickFormat(() => ''));

      // ====== 分组图例（按 cField）======
      g.selectAll('.legend').remove();
      if (groups.length) {
        const legend = g.append('g').attr('class', 'legend')
          .attr('transform', `translate(${Math.max(0, innerWidth - 160)}, 0)`);
        const li = legend.selectAll('g.item')
          .data(groups)
          .join('g')
            .attr('class', 'item')
            .attr('transform', (d, i) => `translate(0, ${i * 18})`);
        li.append('rect')
          .attr('width', 12).attr('height', 12).attr('rx', 2).attr('ry', 2)
          .attr('fill', d => color(d));
        li.append('text')
          .attr('x', 16).attr('y', 6).attr('dy', '0.35em')
          .attr('font-size', 12)
          .text(d => d);
      }

      // ====== 标题（可选）======
      svg.append('text')
        .attr('x', width / 2)
        .attr('y', 28)
        .attr('text-anchor', 'middle')
        .attr('font-size', '20px')
        .text(() => {
          const parts = [];
          parts.push(`${xField} × ${yField}`);
          if (tChosen) parts.push(tIsNumeric ? `+ ${tField}（第二条）` : `+ ${tField}（第二槽位文本）`);
          if (oChosen) parts.push(`○ ${oField}（左侧圆圈，直径映射）`);
          parts.push(`着色：${cField || '无分组'}`);
          return parts.join('｜');
        });

      // 缩放
      const zoom = d3.zoom().on('zoom', (event) => {
        g.attr('transform', event.transform.translate(margin.left + extraLeft, margin.top));
      });
      svg.on('.zoom', null);
      svg.call(zoom);
    }


    // 窗口大小变化后，如已有数据则重绘（加简单防抖）
    let resizeTimer;
    window.addEventListener('resize', () => {
      if (!lastData) return;
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => render(lastData), 120);
    });
  </script>
</body>
</html>
